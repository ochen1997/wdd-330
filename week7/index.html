<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WDD-330 portfolio</title>
  </head>
  <body>
    <h1>Week 7 notes</h1>
    <p>
      The fact that functions are first class objects means they can have
      properties and methods themselves.for example, all functions have a length
      property that returns the number of parameters the function has.
    </p>
    <p>function square(X){ return x*x; }</p>
    <p>
      The call method can be used to set the value of this inside a function to
      an object that is provided as the first argument.for example,
    </p>
    <ul>
      <li>function sayHello(){ return `Hello, my name is ${this.name}`; }</li>
    </ul>
    <p>
      We can create some objects that have a name property, then use the call()
      method to invoke the sayHello function , providing each object as an
      argument. This will then take the value of this in the function. for
      example
    </p>
    <ul>
      <li>const clark = {name: 'clark'};</li>
      <li>const bruce = {name: 'Bruce'};</li>
      <li>sayHello.call(clark);</li>
      <li>Output: 'Hello, my name is Clark'</li>
      <li>sayHello.call(bruce)</li>
      <li>Output: 'Hello, my name is Bruce</li>
    </ul>
    <p>
      There is nothing to stop you adding your own properties to functions in
      the same way that you can add properties to any object in Javascrip.
    </p>
    <p>
      For example you can add a description property to a function that
      describes what it does.
    </p>
    <p>
      If a function takes some time to compute a return value, we can save the
      result in a cache property.
    </p>
    <p>
      Then if if the same argument is used again later, we can return the value
      of cache, rather than having to compute the result again. for example;
    </p>
    <ul>
      <li>
        function square(x){ square.cache = square.cache || {};
        if(!square.cache[x]){ square.cache[x] = x*x } return square.cache[x] }
      </li>
    </ul>
    <p>
      An immediate invoked function Function Expression is an anonymous functuin
      that, as the suggests, is invoked as soon as it is defined.
    </p>
    <p>
      This easily achieved by placing parentheses at the end of the function
      definition, the function also has to be made into an expression, which is
      done by placing the whole declaration inside parentheses as in this
      example.
    </p>
    <ul>
      <li>
        (function(){ const temp = 'World'; console.log(`Hello ${temp}`);})()
      </li>
      <li>Output: 'Hello World'</li>
    </ul>
    <p>
      There is no way to remove variable from scope once it is been declared,if
      avariable is only required temporarily, it may cause confusion if it si
      still avaialable later in the code.
    </p>
    <p>
      Even worse, the name of the variable may clash with another piece of code
      resulting in errors, placing any code that uses the temporary variable
      inside an IIFE to swap the value of two global variables.
    </p>
    <p>
      An IIFE can be used to set up any initialization code that there will be
      no need for a gian.Because the code is only run once, there is no need to
      create any reuseable, named functions, and all the variables will also be
      temporary.
    </p>
    <p>
      An IIFE will be invoked once and can set up any variable objects and event
      handlers when the page loads.
    </p>
    <p>
      An IIFE can be used to enclose a block of code inside its own private
      scope so it does not interfere with any other part of the program.
    </p>
    <p>Using IIFEs inthis way means code can be added or removed separately.</p>
    <p>
      The dynamic nature of javaScript means that a function is able to not only
      call itsself, but define itself, and even redefine itself. This is done by
      assigning an anonymous function to avariable that has the same name as the
      function.
    </p>
    <p>
      A recursive function is one that invokes itself until a certain condition
      is met. it is a useful tool to use when iterative processes are involved.
      a commom example is a function that calculates the factorila of numbers.
    </p>
    <p>
      The increase in the use of asynchronous programming in Javascript has
      meant that more and more callbacks are being used. This can result in
      messy and confusing code, this is when more than one callback is used in
      the same function, resulting in a large number of nested blocks that are
      dificult to comprehend
    </p>
    <p>
      When promise is created, it cals an asynchronous operation and is then
      said to be pending. it remains in this state while the operation is taking
      place. At this state, the promise is once said to be unsettled. Once the
      operationhas completed, the promise is said to have been settled. A
      settled promise can result in two different outcomes.
    </p>
    <ul>
      <li>Resolved- the asynchronous operation was completed successfully.</li>
      <li>
        Rejected- the asynchronous operation did not work as expected, was not
        successfully completed or resulted in an error.
      </li>
    </ul>
    <p>
        There is no way to remove variable from scope once it is been declared. if avariable is only required temporarily, it 
      A promise is created using constructor function.This takes a function
      called an excutor as an argument. The excutor initializes the promise and
      starts asynchronous operation. it also accepts two functions as arguments:
      the resolve() function is called if the operation is successful, and the
      reject() function is called if the the operation fails.
    </p>
    <p>
      Promise come into their own when multiple asynchronous tasks are required
      to be carried out after other. if each function that performs an
      asynchronous operation returns a promise, we can chain then then() method
      together to form a sequential piece of code that is easy to read. Each
      promise will only begin once the previous promise has been settled.
    </p>
    <p>
      Callbacks can be used to build more generalized functions. instead of
      having lots of specific functions, one function can be written that
      accepts a callback.
    </p>
    <p>
      Higher order functions are functions that accept another function as an
      argument, or return another function as a result or both.
    </p>
    <p>
      Curring is a process that involves the partial application of functions.
      it is named after the logician Haskell Curry.
    </p>
    <p>
      A function is said to be curried when not all arguments have been supplied
      to the function, so it returns another function that retains the arguments
      already provided, and expects the remaining arguments already provided,
      and expects the remaining arguments were omitted when the original
      function was called. A final result is only returned once all the expected
      arguments have eventually been provided.
    </p>
    <p>
      Currying relies on higher order function that are able to return partially
      applied functions. All curried functions are hiher-order functions becuase
      they return a function, but not all higher- order functions are curried.
    </p>
    <p>
      Curring allows you to turn a single function into a series of function
      instead. This is useful if you find that you are frequently calling a
      function with the same argument.
    </p>
  </body>
</html>
